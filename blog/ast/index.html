<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Kast&#x27;s AST parser |  Kast  </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <link rel="icon" type="image/png" href="/favicon.ico">
    
    <style>
    :root {
        /* Primary theme color */
        --primary-color: #FED43F;
        /* Primary theme text color */
        --primary-text-color: #543631;
        --primary-text-color-over: #000;
        /* Primary theme link color */
        --primary-link-color: #F9BB2D;
        /* Secondary color: the background body color */
        --secondary-color: #fcfaf6;
        --secondary-text-color: #303030;
        /* Highlight text color of table of content */
        --toc-highlight-text-color: #d46e13;
        --toc-background-color: white;
        --code-color: #4a4a4a;
        /* one-dark */
        --code-background-color: #2b303b;

        --shadow-color: #ddd;

        /* Font used for headers (h1 & h2) */
        --header-font-family: "Fira Sans", sans-serif;
        /* Font used for text */
        --text-font-family: "Fira Sans", sans-serif;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --primary-color: #382929;
            --primary-text-color: #d7d7d7;
            --primary-text-color-over: #FFF;
            --primary-link-color: #9b9b9b;
            --secondary-color: #282828;
            --secondary-text-color: #f2f2f2;
            --toc-highlight-text-color: #f2f2f2;
            --toc-background-color: #3a3a3a;
            --code-color: white;
            /* one-dark */
            --code-background-color: #2b303b;

            --shadow-color: #202020;
            --header-font-family: "Fira Sans", sans-serif;
            --text-font-family: "Fira Sans", sans-serif;
        }
    }
</style>

    
    <link href="https://fonts.googleapis.com/css?family=Alfa+Slab+One&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Fira+Sans:400,500,600&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="/normalize.css">
    <link rel="stylesheet" href="https://kast-lang.org/juice.css">
    
    <link rel="stylesheet" href="https://kast-lang.org/carbon.css">
    
</head>

<body>
    
<header class="box-shadow">
    

<a href="https://kast-lang.org/">
    <div class="logo">
        <img src="https://kast-lang.org/logo.svg" alt="logo">
        Kast
    </div>
</a>

<nav>
    
    
        
        <a class="nav-item subtitle-text" href="https://play.kast-lang.org">Playground</a>
        
        <a class="nav-item subtitle-text" href="/learn">Learn</a>
        
        <a class="nav-item subtitle-text" href="/blog">Blog</a>
        
        <a class="nav-item subtitle-text" href="https://github.com/kast-lang/kast">Github</a>
        
    
</nav>

</header>


    <main>
        
        
        
        
        
        <div class="toc">
            <div class="toc-sticky">
                
                <div class="toc-item">
                    <a class="subtext" href="https://kast-lang.org/blog/ast/#overview">Overview</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://kast-lang.org/blog/ast/#storing-syntax-definitions">Storing syntax definitions</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://kast-lang.org/blog/ast/#parsing-single-definition">Parsing single definition</a>
                </div>
                
                
            </div>
        </div>
        
        

        <div class="content text">
            
<div class="heading-text">Kast&#x27;s AST parser</div>
<p>In Kast there is no builtin syntax. Except for syntax for adding new syntax.</p>
<p>The standard syntax is defined in <code>std/syntax.ks</code>, but you can ignore it and define your own instead.</p>
<p>When parsing code into AST, Kast treats everything as an expression,
and every syntax definition is extending what an expression can be.</p>
<p>For example, you could define a ternary if like in Python like so:</p>
<pre style="background-color:#2b303b;color:#6c7079;"><code><span style="color:#abb2bf;">syntax ternary-if -&gt; 20 = true_value &quot;if&quot; condition &quot;else&quot; false_value
</span></code></pre>
<p>This defines syntax for <code>ternary-if</code> (which should be defined somewhere)
which is right associative (<code>-&gt;</code>), has priority (precedence) of <code>20</code>,
and is defined as <code>true_value "if" condition "else" false_value</code> where
<code>true_value</code>, <code>condition</code> and <code>false_value</code> can be anything defined by
other syntax rules with higher priority (or be a simple single-token value),
and the <code>if</code> and <code>else</code> are "keywords".</p>
<p>Keywords can also be punctuation, so a ternary operator from C could be defined as:</p>
<pre style="background-color:#2b303b;color:#6c7079;"><code><span style="color:#abb2bf;">syntax ternary-operator -&gt; 20 = condition &quot;?&quot; then_case &quot;:&quot; else_case
</span></code></pre>
<!-- does that make sense? -->
<p>The AST parsing algorithm takes a sequence of tokens and a collection of syntax definitions stored in such data structure and constructs an AST.</p>
<p>An example of parsed AST for <code>a if b else c ? d : e</code>:</p>
<pre style="background-color:#2b303b;color:#6c7079;"><code><span style="color:#abb2bf;">ternary-if {
</span><span style="color:#abb2bf;">    true_value = a
</span><span style="color:#abb2bf;">    condition = b
</span><span style="color:#abb2bf;">    false_value = ternary-operator {
</span><span style="color:#abb2bf;">        condition = c
</span><span style="color:#abb2bf;">        then_case = d
</span><span style="color:#abb2bf;">        else_case = e
</span><span style="color:#abb2bf;">    }
</span><span style="color:#abb2bf;">}
</span></code></pre>
<h2 id="overview">Overview</h2>
<p>The algorithm starts by trying to parse a smallest
complete expression starting at the beginning.
For example, it would parse just <code>a</code> from <code>a + b + c</code>,
or it would parse <code>(a + b)</code> from <code>(a + b) + c + d</code>.</p>
<p>After that, it tries to expand the first expression by making it a part of a more complex expression, finding the next smallest one.
For example <code>a</code> from <code>a + b + c</code> would be expanded to <code>a + b</code>,
and <code>(a + b)</code> from <code>(a + b) + c + d</code> would be expanded to <code>(a + b) + c</code>.</p>
<p>Then it tries to expand it again and again until it can make no more progress.</p>
<p>The first step is basically same as expanding from nothing, so what we do is this:</p>
<pre data-lang="rs" style="background-color:#2b303b;color:#6c7079;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#cd74e8;">fn </span><span style="color:#5cb3fa;">parse_expr</span><span style="color:#abb2bf;">() -&gt; Option&lt;Ast&gt; {
</span><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> already_parsed </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">None;
</span><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">while let </span><span style="color:#abb2bf;">Ok(expanded) </span><span style="color:#adb7c9;">= </span><span style="color:#5ebfcc;">try_expand</span><span style="color:#abb2bf;">(already_parsed) {
</span><span style="color:#abb2bf;">        already_parsed </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">Some(expanded);
</span><span style="color:#abb2bf;">    }
</span><span style="color:#abb2bf;">    already_parsed
</span><span style="color:#abb2bf;">}
</span></code></pre>
<!-- Comment an actual line of source code -->
<p>So, a single expand operation is trying to parse either a simple (single-token) value,
or a single syntax definition.
In order to do so, we store all the syntax definitions in a helper data structure.</p>
<h2 id="storing-syntax-definitions">Storing syntax definitions</h2>
<p>Syntax definitions are stored in a <a href="https://en.wikipedia.org/wiki/Trie">trie</a> -
a tree data structure, where each node represents partially parsed syntax definition.</p>
<p>An edge from parent to a child in this tree represents making progress,
which is either following a keyword, or parsing an inner value.
Some nodes are terminal, meaning that they represent fully parsed syntax definition.</p>
<p>For example, for storing <code>ternary-if</code> definition like above
there would be a path from the root of the tree following edges:</p>
<ul>
<li>value</li>
<li><code>if</code> keyword</li>
<li>value</li>
<li><code>else</code> keyword</li>
<li>value</li>
</ul>
<p>The final node after following this path is marked as terminal,
corresponding to the <code>ternary-if</code> definition.</p>
<p>If, in addition to this syntax we also had a similar syntax definition but without the else case
(<code>syntax just-if -&gt; 20 = true_value "if" condition</code>),
and lets say a binary <code>+</code> operator (defined as <code>syntax plus &lt;- 30 = a "+" b</code>),
then we would have a tree like this:</p>
<!-- totally not a suspicious comment &mdash;&mdash;> <div style="display: none;"> -->
<pre style="background-color:#2b303b;color:#6c7079;"><code><span style="color:#abb2bf;">root {
</span><span style="color:#abb2bf;">    -&gt; value {
</span><span style="color:#abb2bf;">        -&gt; &quot;+&quot; {
</span><span style="color:#abb2bf;">            -&gt; value {
</span><span style="color:#abb2bf;">                terminal &quot;plus&quot;
</span><span style="color:#abb2bf;">            }
</span><span style="color:#abb2bf;">        }
</span><span style="color:#abb2bf;">        -&gt; &quot;if&quot; {
</span><span style="color:#abb2bf;">            -&gt; value {
</span><span style="color:#abb2bf;">                terminal &quot;just-if&quot;
</span><span style="color:#abb2bf;">                -&gt; &quot;else&quot; {
</span><span style="color:#abb2bf;">                    -&gt; value {
</span><span style="color:#abb2bf;">                        terminal &quot;ternary-if&quot;
</span><span style="color:#abb2bf;">                    }
</span><span style="color:#abb2bf;">                }
</span><span style="color:#abb2bf;">            }
</span><span style="color:#abb2bf;">        }
</span><span style="color:#abb2bf;">    }
</span><span style="color:#abb2bf;">}
</span></code></pre>
<p>Actually, since we need to expand either starting with an already_parsed value or with nothing,
we store two roots - one starting without a value and one with,
instead of having a value edge from the root.</p>
<h2 id="parsing-single-definition">Parsing single definition</h2>
<p>So, in order to parse a single syntax definition we need to traverse this tree to some terminal node.</p>
<p>We try to make as much progress as we can in a loop.
In every iteration, we first see if the token ahead is a keyword that we can follow with.
If not, and if there exists a value edge from the current node, then we
try to parse a value by recursively calling into <code>parse_expr</code>.
If it succeeded to parse something, then we follow the value edge.
In other cases we stop and check that we arrived in a terminal node.
If not, then the code has a syntax error.</p>
<p>When parsing inner values it is also important to take
priorities and associativities of syntax definitions into consideration.
This means that both <code>parse_expr</code> and <code>expand</code> actually are also taking extra argument
which is the binding power (priority + associativity) of the outer expression, if there is one.
The only exception is if we are parsing an inner value inside parentheses
(like if we are parsing <code>"(" expr ")"</code> syntax definition).
In such case, inner values are parsed just like the top level expression.
This also means that binding power is stored in the syntax trie in every node (other than root),
and when making progress we check that if we should actually proceed or not.</p>
<p>Here's an incomplete implementation:</p>
<pre data-lang="rs" style="background-color:#2b303b;color:#6c7079;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#cd74e8;">fn </span><span style="color:#5cb3fa;">expand</span><span style="color:#abb2bf;">(</span><span style="color:#eb6772;">start_value</span><span style="color:#abb2bf;">: Option&lt;Ast&gt;, </span><span style="color:#eb6772;">outer_binding_power</span><span style="color:#abb2bf;">: BindingPower) -&gt; Result&lt;Ast&gt; {
</span><span style="color:#abb2bf;">    </span><span style="font-style:italic;color:#5f697a;">// first see if its a simple value
</span><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">if </span><span style="color:#adb7c9;">!</span><span style="color:#5ebfcc;">peek_token</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">is_keyword</span><span style="color:#abb2bf;">() {
</span><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">return </span><span style="color:#abb2bf;">Ok(Ast::Simple(</span><span style="color:#5ebfcc;">pop_token</span><span style="color:#abb2bf;">()));
</span><span style="color:#abb2bf;">    }
</span><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> node </span><span style="color:#adb7c9;">= </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> start_value {
</span><span style="color:#abb2bf;">        Some(</span><span style="color:#adb7c9;">_</span><span style="color:#abb2bf;">) </span><span style="color:#adb7c9;">=&gt;</span><span style="color:#abb2bf;"> root_with_value,
</span><span style="color:#abb2bf;">        None </span><span style="color:#adb7c9;">=&gt;</span><span style="color:#abb2bf;"> root_without_value,
</span><span style="color:#abb2bf;">    };
</span><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> inner_values </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">Vec::from_iter(start_value);
</span><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">loop </span><span style="color:#abb2bf;">{
</span><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">if let </span><span style="color:#abb2bf;">Some(next_node) </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> node.next.</span><span style="color:#5ebfcc;">get</span><span style="color:#abb2bf;">(Edge::Keyword(</span><span style="color:#5ebfcc;">peek_token</span><span style="color:#abb2bf;">())) {
</span><span style="color:#abb2bf;">            </span><span style="color:#cd74e8;">if </span><span style="color:#adb7c9;">!</span><span style="color:#5ebfcc;">check_binding_power</span><span style="color:#abb2bf;">(outer_binding_power, next_node) {
</span><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">break</span><span style="color:#abb2bf;">;
</span><span style="color:#abb2bf;">            }
</span><span style="color:#abb2bf;">            node </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> next_node;
</span><span style="color:#abb2bf;">        } </span><span style="color:#cd74e8;">else if let </span><span style="color:#abb2bf;">Some(next_node) </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> node.next.</span><span style="color:#5ebfcc;">get</span><span style="color:#abb2bf;">(Edge::Value).</span><span style="color:#5ebfcc;">is_some</span><span style="color:#abb2bf;">() {
</span><span style="color:#abb2bf;">            </span><span style="color:#cd74e8;">if </span><span style="color:#adb7c9;">!</span><span style="color:#5ebfcc;">check_binding_power</span><span style="color:#abb2bf;">(outer_binding_power, next_node) {
</span><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">break</span><span style="color:#abb2bf;">;
</span><span style="color:#abb2bf;">            }
</span><span style="color:#abb2bf;">            </span><span style="color:#cd74e8;">if let </span><span style="color:#abb2bf;">Some(value) </span><span style="color:#adb7c9;">= </span><span style="color:#5ebfcc;">parse_expr</span><span style="color:#abb2bf;">(binding_power_for_inner_values) {
</span><span style="color:#abb2bf;">                inner_values.</span><span style="color:#5ebfcc;">push</span><span style="color:#abb2bf;">(value);
</span><span style="color:#abb2bf;">                node </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> next_node;
</span><span style="color:#abb2bf;">            } </span><span style="color:#cd74e8;">else </span><span style="color:#abb2bf;">{
</span><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">break</span><span style="color:#abb2bf;">;
</span><span style="color:#abb2bf;">            }
</span><span style="color:#abb2bf;">        } </span><span style="color:#cd74e8;">else </span><span style="color:#abb2bf;">{
</span><span style="color:#abb2bf;">            </span><span style="color:#cd74e8;">break</span><span style="color:#abb2bf;">;
</span><span style="color:#abb2bf;">        }
</span><span style="color:#abb2bf;">    }
</span><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">if</span><span style="color:#abb2bf;"> node </span><span style="color:#adb7c9;">==</span><span style="color:#abb2bf;"> start_node {
</span><span style="color:#abb2bf;">        </span><span style="font-style:italic;color:#5f697a;">// made no progress
</span><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">return </span><span style="color:#abb2bf;">Err;
</span><span style="color:#abb2bf;">    }
</span><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> definition </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> node.terminal.</span><span style="color:#5ebfcc;">expect</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&quot;arrived in non-terminal node&quot;</span><span style="color:#abb2bf;">);
</span><span style="color:#abb2bf;">    Ok(Ast::Complex(definition, inner_values))
</span><span style="color:#abb2bf;">}
</span></code></pre>
<p>There are more missing details in this implementation.</p>
<p>For example, if there is a syntax definition which contains a keyword
which is also used in the beginning of another definition,
then we shouldn't start parsing a new one while in the process of parsing another.</p>
<p>For example, if we had these definitions:</p>
<pre style="background-color:#2b303b;color:#6c7079;"><code><span style="color:#abb2bf;">syntax if &lt;- 20 = &quot;if&quot; condition &quot;(&quot; body &quot;)&quot;
</span><span style="color:#abb2bf;">syntax call &lt;- 40 = f arg
</span><span style="color:#abb2bf;">syntax parenthesised &lt;- 100 = &quot;(&quot; expr &quot;)&quot;
</span></code></pre>
<p>In this case, when parsing condition of the <code>if</code> we should treat the "(" as continuation of the if, not as start of the second argument of <code>call</code> with <code>condition</code> being the first.</p>


        </div>

        

    </main>

    
<!-- <footer> -->
<!--     <small class="subtext"> -->
<!--         <a href="https://kast-lang.org">kast-lang.org</a> -->
<!--     </small> -->
<!-- </footer> -->

</body>
<script>
    const scrollHandler = entries => {
        // Find the first entry which intersecting and ratio > 0.9 to highlight.
        let entry = entries.find(entry => {
            return entry.isIntersecting && entry.intersectionRatio > 0.9;
        });
        if (!entry) return;

        document.querySelectorAll(".toc a").forEach((item) => {
            item.classList.remove("active");
        });

        // let url = new URL(`#${entry.target.id}`);
        let link = document.querySelector(`.toc a[href$="${decodeURIComponent(`#${entry.target.id}`)}"]`)
        if (link) {
            link.classList.add("active");
            link.scrollIntoView({ behavior: "auto", block: "nearest" });
        }
    };
    // Set -100px root margin to improve highlight experience.
    const observer = new IntersectionObserver(scrollHandler, { threshold: 1 });
    let items = document.querySelectorAll('h1,h2,h3,h4,h5,h6');
    items.forEach(item => observer.observe(item));
</script>

</html>